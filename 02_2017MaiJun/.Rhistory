nome=xml_data[[i]]$nome,
tipoProposicao=xml_data[[i]]$tipoProposicao$sigla,
numero=as.numeric(xml_data[[i]]$numero),
ano=xml_data[[i]]$ano,
orgaoNumerador=xml_data[[i]]$orgaoNumerador$nome,
datApresentacao=xml_data[[i]]$datApresentacao,
txtEmenta=xml_data[[i]]$txtEmenta,
txtExplicacaoEmenta=xml_data[[i]]$txtExplicacaoEmenta,
txtRegime=xml_data[[i]]$regime$txtRegime,
txtApreciacao=xml_data[[i]]$apreciacao$txtApreciacao,
qtdAutores=xml_data[[i]]$qtdAutores,
autor1=xml_data[[i]]$autor1$txtNomeAutor,
ultimoDespacho=xml_data[[i]]$ultimoDespacho$txtDespacho,
situacao=xml_data[[i]]$situacao$descricao,
proposicaoPrincipal=xml_data[[i]]$proposicao$nome
)
baseProjetos <- rbind(baseProjetos, df)
}
}
}
# tipo proposicoes
TIPOLEI <- c(
'MPV', 'MSC', 'MSF', 'MSG', 'OF.', 'P.C', 'PDC', 'PDF',
'PDL', 'PDN', 'PDR', 'PDS', 'PEC', 'PL.', 'PLD', 'PLN',
'PLP', 'PRC', 'PRN', 'QOD', 'RCP', 'REC', 'REP', 'REQ',
'VET'
)
baseProjetos <- NULL
for(ano in 1989:2017){
for(tipo in TIPOLEI){
url <-  paste0("http://www.camara.leg.br/SitCamaraWS/Proposicoes.asmx/ListarProposicoes?",
"sigla=",tipo,"&numero=&ano=",ano,
"&datApresentacaoIni=&datApresentacaoFim=&idTipoAutor=&parteNomeAutor=",
"&siglaPartidoAutor=&siglaUFAutor=&generoAutor=&codEstado=&codOrgaoEstado=&emTramitacao=")
data <- xmlParse(url, isURL=TRUE, asTree = TRUE, useInternalNodes = TRUE)
xml_data <- xmlToList(data)
for(i in 1:length(xml_data)){
df <- data.frame(
id=as.numeric(xml_data[[i]]$id),
nome=xml_data[[i]]$nome,
tipoProposicao=xml_data[[i]]$tipoProposicao$sigla,
numero=as.numeric(xml_data[[i]]$numero),
ano=xml_data[[i]]$ano,
orgaoNumerador=xml_data[[i]]$orgaoNumerador$nome,
datApresentacao=xml_data[[i]]$datApresentacao,
txtEmenta=xml_data[[i]]$txtEmenta,
txtExplicacaoEmenta=xml_data[[i]]$txtExplicacaoEmenta,
txtRegime=xml_data[[i]]$regime$txtRegime,
txtApreciacao=xml_data[[i]]$apreciacao$txtApreciacao,
qtdAutores=xml_data[[i]]$qtdAutores,
autor1=xml_data[[i]]$autor1$txtNomeAutor,
ultimoDespacho=xml_data[[i]]$ultimoDespacho$txtDespacho,
situacao=xml_data[[i]]$situacao$descricao,
proposicaoPrincipal=xml_data[[i]]$proposicao$nome
)
baseProjetos <- rbind(baseProjetos, df)
}
}
}
url
i
xml_data[[i]]$id
xml_data[[i]]$descricao
xml_data[[i]]$erro$descricao
xml_data
xml_data[[1]]$descricao
xml_data$descricao
str(xml_data)
d <- xml_data
d
names(d)
names(d)[1]
names(d)[1] == 'descricao'
library(XML)
# tipo proposicoes
TIPOLEI <- c(
'MPV', 'MSC', 'MSF', 'MSG', 'OF.', 'P.C', 'PDC', 'PDF',
'PDL', 'PDN', 'PDR', 'PDS', 'PEC', 'PL.', 'PLD', 'PLN',
'PLP', 'PRC', 'PRN', 'QOD', 'RCP', 'REC', 'REP', 'REQ',
'VET'
)
baseProjetos <- NULL
for(ano in 1989:2017){
for(tipo in TIPOLEI){
url <-  paste0("http://www.camara.leg.br/SitCamaraWS/Proposicoes.asmx/ListarProposicoes?",
"sigla=",tipo,"&numero=&ano=",ano,
"&datApresentacaoIni=&datApresentacaoFim=&idTipoAutor=&parteNomeAutor=",
"&siglaPartidoAutor=&siglaUFAutor=&generoAutor=&codEstado=&codOrgaoEstado=&emTramitacao=")
data <- xmlParse(url, isURL=TRUE, asTree = TRUE, useInternalNodes = TRUE)
xml_data <- xmlToList(data)
if(names(xml_data)[1] != 'descricao'){
for(i in 1:length(xml_data)){
df <- data.frame(
id=as.numeric(xml_data[[i]]$id),
nome=xml_data[[i]]$nome,
tipoProposicao=xml_data[[i]]$tipoProposicao$sigla,
numero=as.numeric(xml_data[[i]]$numero),
ano=xml_data[[i]]$ano,
orgaoNumerador=xml_data[[i]]$orgaoNumerador$nome,
datApresentacao=xml_data[[i]]$datApresentacao,
txtEmenta=xml_data[[i]]$txtEmenta,
txtExplicacaoEmenta=xml_data[[i]]$txtExplicacaoEmenta,
txtRegime=xml_data[[i]]$regime$txtRegime,
txtApreciacao=xml_data[[i]]$apreciacao$txtApreciacao,
qtdAutores=xml_data[[i]]$qtdAutores,
autor1=xml_data[[i]]$autor1$txtNomeAutor,
ultimoDespacho=xml_data[[i]]$ultimoDespacho$txtDespacho,
situacao=xml_data[[i]]$situacao$descricao,
proposicaoPrincipal=xml_data[[i]]$proposicao$nome
)
baseProjetos <- rbind(baseProjetos, df)
}
}
}
}
xml_data[[i]]$nome
xml_data[[i]]$id
as.numeric(xml_data[[i]]$id)
xml_data[[i]]$nome
xml_data[[i]]$tipoProposicao$sigla
as.numeric(xml_data[[i]]$numero)
xml_data[[i]]$ano
xml_data[[i]]$orgaoNumerador$nome
xml_data[[i]]$datApresentacao
xml_data[[i]]$txtEmenta
xml_data[[i]]$txtExplicacaoEmenta
xml_data[[i]]$regime$txtRegime
xml_data[[i]]$apreciacao$txtApreciacao
xml_data[[i]]$qtdAutores
xml_data[[i]]$autor1$txtNomeAutor
xml_data[[i]]$ultimoDespacho$txtDespacho
xml_data[[i]]$situacao$descricao
xml_data[[i]]$proposicao$nome
xml_data[[i]]$situacao$principal$proposicaoPrincipal
xml_data[[i]]$situacao$orgao$siglaOrgaoEstado
xml_data[[i]]$situacao$principal$proposicaoPrincipal
xml_data[[i]]$situacao$descricao
# tipo proposicoes
TIPOLEI <- c(
'MPV', 'MSC', 'MSF', 'MSG', 'OF.', 'P.C', 'PDC', 'PDF',
'PDL', 'PDN', 'PDR', 'PDS', 'PEC', 'PL.', 'PLD', 'PLN',
'PLP', 'PRC', 'PRN', 'QOD', 'RCP', 'REC', 'REP', 'REQ',
'VET'
)
baseProjetos <- NULL
for(ano in 1989:2017){
for(tipo in TIPOLEI){
url <-  paste0("http://www.camara.leg.br/SitCamaraWS/Proposicoes.asmx/ListarProposicoes?",
"sigla=",tipo,"&numero=&ano=",ano,
"&datApresentacaoIni=&datApresentacaoFim=&idTipoAutor=&parteNomeAutor=",
"&siglaPartidoAutor=&siglaUFAutor=&generoAutor=&codEstado=&codOrgaoEstado=&emTramitacao=")
data <- xmlParse(url, isURL=TRUE, asTree = TRUE, useInternalNodes = TRUE)
xml_data <- xmlToList(data)
if(names(xml_data)[1] != 'descricao'){
for(i in 1:length(xml_data)){
df <- data.frame(
id=as.numeric(xml_data[[i]]$id),
nome=xml_data[[i]]$nome,
tipoProposicao=xml_data[[i]]$tipoProposicao$sigla,
numero=as.numeric(xml_data[[i]]$numero),
ano=xml_data[[i]]$ano,
orgaoNumerador=xml_data[[i]]$orgaoNumerador$nome,
datApresentacao=xml_data[[i]]$datApresentacao,
txtEmenta=xml_data[[i]]$txtEmenta,
txtExplicacaoEmenta=xml_data[[i]]$txtExplicacaoEmenta,
txtRegime=xml_data[[i]]$regime$txtRegime,
txtApreciacao=xml_data[[i]]$apreciacao$txtApreciacao,
qtdAutores=xml_data[[i]]$qtdAutores,
autor1=xml_data[[i]]$autor1$txtNomeAutor,
ultimoDespacho=xml_data[[i]]$ultimoDespacho$txtDespacho,
situacao=xml_data[[i]]$situacao$descricao,
situacaoOrgao=xml_data[[i]]$situacao$orgao$siglaOrgaoEstado,
situacaoProposicaoPrincipal=xml_data[[i]]$situacao$principal$proposicaoPrincipal
)
baseProjetos <- rbind(baseProjetos, df)
}
}
}
}
3+2
3:4
a <- 9
library(RCurl)
library(RCurl)
library(XML)
l <- readHTMLList("http://lattes.cnpq.br/9394532830433721")
url <- "http://buscatextual.cnpq.br/buscatextual/visualizacv.do?id=K4771292E6"
l <- readHTMLList(url)
url <- "http://buscatextual.cnpq.br/buscatextual/download.do?metodo=apresentar&idcnpq=9394532830433721"
l <- readHTMLList(url)
setwd("F:/_Pesquisa/PosDoc/_Github/03_2017JulAgo")
return(x)
source("..\\02_2017MaiJun\\05_EncodeDecode.R")
if(!require(tm)) { install.packages('tm') }
if(!require(qdap)) { install.packages('qdap') }
# if(!require(profvis)) { install.packages('profvis') }
if(!require(tidyverse)) { install.packages('tidyverse') }
if(!require(tidytext)) { install.packages('tidytext') }
if(!require(tidyr)) { install.packages('tidyr') }
if(!require(dplyr)) { install.packages('dplyr') }
#####################
# funções de limpeza
#####################
# aplicada a vetores de caracteres (apenas inglês)
qdap_clean <- function(x){
x <- replace_abbreviation(x)
x <- replace_contraction(x)
x <- replace_number(x)
x <- replace_ordinal(x)
x <- replace_ordinal(x)
x <- replace_symbol(x)
x <- tolower(x)
return(x)
}
# aplicada a corpus
tm_clean <- function(corpus, stopwords){
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, stripWhitespace)
corpus <- tm_map(corpus, removeWords, stopwords)
return(corpus)
}
ini <- 2003
fim <- 2016
partido <- "PT"
# profvis({ # identifica gragalos de processamento
# lê arquivo com todos os discursos
pasta <- "..\\..\\CorporaRDS\\"
arquivo <- paste0("corpora_", partido, "_", ini, "_", fim, ".rds")
vdisc <- readRDS(paste0(pasta, arquivo))
# Para fazer um corpus volátil, R precisa interpretar cada
# elemento no vetor de discursos **vdisc** como um documento.
# O pacote **tm** fornece as chamadas funções de Origem para
# fazer essa conversão. A função de Origem chamada VectorSource()
# é utilizada uma vez que os dados do discurso estão contidos em um vetor.
docs <- VectorSource(vdisc)
docs <- VCorpus(docs) # corpus volátil
#### removendo stopwords
stopw <- readLines("stopwords_pt.txt")
#### removendo palavras com pouca informação
stopw <- c(stopw, readLines("stopwords_pt_discurso.txt"))
#### removendo nomes
stopw <- c(stopw, readLines("stopwords_pt_nomes.txt"))
# retira acentos das stopwords
stopw <- retira_acentos(stopw)
# limpeza com tm_clean
docs <- tm_clean(docs, stopw)
# deixando apenas os radicais das palavras
# docs <- tm_map(docs, stemDocument, language = "portuguese")
# remonta o vetor de discursos após os discursos
# terem passado pelo filtro; isso porque o pacote
# qdap só pode ser usado sobre vetores
n <- length(docs)
vdisc <- vector("character", n)
for(i in 1:n){
vdisc[i] <- docs[[i]]$content
}
# termFreq, do pacote tm, também funciona sobre vetores,
# porém é mais lenta que freq_terms do pacote qdap
# system.time(tf <- termFreq(vdisc))
# ord <- order(tf, decreasing=TRUE)
# tf <- tf[ord[1:30]]
# wordcloud(names(tf), tf, max.words = 20)
# system.time(tfq <- freq_terms(vdisc, at.least = 3, top = 20))
# determina termos mais frequentes com freq_terms (qdap)
tfq <- freq_terms(vdisc, at.least = 3, top = 200)
###########
# bigramas
###########
# data frame
bigramas <- data.frame(id_discurso = 1:length(vdisc),
text = vdisc,
stringsAsFactors = F)
# bigramas
bigramas <- bigramas %>%
unnest_tokens(bigram, text, token = "ngrams", n = 2)
# ordena bigramas
bigramas <- bigramas %>%
dplyr::count(bigram, sort = TRUE)
# remove bigramas com menos de 3 ocorrências
bigramas <- bigramas[bigramas$n >= 3,]
# remove bigramas sem informação
bigramas <- bigramas[!(bigramas$bigram %in% readLines("stopbigramas_pt.txt")), ]
dados <- list(docs, tfq, bigramas)
# })
arquivo <- paste0("corpora_", partido, "_", ini, "_", fim, "_limpo.rds")
saveRDS(dados, paste0(pasta, arquivo))
a <- readRDS("..\\..\\DadosRDS\\discurso_2000_2017.rds")
View(a)
setwd("F:/_Pesquisa/PosDoc/_Github/01_2017MarAbr")
####################################################
# Carrega a lista de discursos em plenário a partir
# do sítio de dados abertos da Câmara dos Deputados
#
# Listar Discurso Plenário
# http://www2.camara.leg.br/transparencia/dados-abertos/dados-abertos-legislativo/webservices/sessoesreunioes-2/listardiscursosplenario
####################################################
library(XML)
library(stringr)
# marca o momento do início do algorítmo
ptm <- proc.time()
print('Início')
print(ptm)
# O intervalo entre as datas não pode ser superior a 360 dias.
dataIni <- '01/01/'
dataFim <- '23/12/'
# pasta para a gravação dos arquivos
pasta <- "..\\..\\Dados\\"
trim <- function (x){
x <- gsub("\n", "", x)
str_trim(x)
}
for(ano in 2017:2017){
# monta a URL com base no ano e período
url <-  paste0("http://www.camara.leg.br/sitcamaraws/SessoesReunioes.asmx/ListarDiscursosPlenario?",
"dataIni=",dataIni,ano,"&dataFim=",dataFim,ano,
"&codigoSessao=&parteNomeParlamentar=&siglaPartido=&siglaUF="
)
# enquanto não conseguir ler os dados do ano/período no link, tenta novamente
repeat{
data <- try(xmlParse(url, isURL=TRUE, asTree = TRUE, useInternalNodes = TRUE), TRUE)
if(typeof(data) == "externalptr") break
print("Erro ao acessar a URL")
Sys.sleep(0.5)
}
# converte formato XML para lista do R
xml_data <- xmlToList(data)
# sessaoDiscurso <- NULL
# faseSessao <- NULL
discurso <- NULL
# para cada sessão no ano/período ...
for(i in 1:length(xml_data)){
#df1 <- data.frame(
#  codigo=trim(xml_data[[i]]$codigo),
#  data=xml_data[[i]]$data,
#  numero=xml_data[[i]]$numero,
#  tipo=xml_data[[i]]$tipo
#)
#sessaoDiscurso <- rbind(sessaoDiscurso, df1)
# ... verifica se existem fases e ...
if(length(xml_data[[i]]$fasesSessao)>0){
# ... para cada fase ...
for(j in 1:length(xml_data[[i]]$fasesSessao)){
#df2 <- data.frame(
#  codigo=trim(xml_data[[i]]$codigo),
#  codigoFase=xml_data[[i]]$fasesSessao[j]$faseSessao$codigo,
#  descricao=xml_data[[i]]$fasesSessao[j]$faseSessao$descricao
#)
#faseSessao <- rbind(faseSessao, df2)
# ... verifica se existem discursos e faz a leitura dos dados de indexação
if(length(xml_data[[i]]$fasesSessao[j]$faseSessao$discursos)>0){
for(k in 1:length(xml_data[[i]]$fasesSessao[j]$faseSessao$discursos)){
df3 <- data.frame(
codigoSessao=trim(xml_data[[i]]$codigo),
dataSessao=xml_data[[i]]$data,
numeroSessao=xml_data[[i]]$numero,
tipoSessao=xml_data[[i]]$tipo,
codigoFase=xml_data[[i]]$fasesSessao[j]$faseSessao$codigo,
descricaoFase=xml_data[[i]]$fasesSessao[j]$faseSessao$descricao,
numeroQuarto=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$numeroQuarto,
numeroInsercao=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$numeroInsercao,
numeroOrador=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$orador$numero,
nomeOrador=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$orador$nome,
partidoOrador=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$orador$partido,
ufOrador=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$orador$uf,
txtIndexacao=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$txtIndexacao,
sumario=xml_data[[i]]$fasesSessao[j]$faseSessao$discursos[k]$discurso$sumario
)
discurso <- rbind(discurso, df3)
}
}
}
}
# mostra ano e índice do discurso lido ...
print(paste0(ano,' - ',i))
# ... e o tempo decorrido para a leitura
print(proc.time() - ptm)
ptm <- proc.time()
}
#write.csv2(sessaoDiscurso, paste0("sessao_discurso_",ano,".csv"))
#write.csv2(faseSessao, paste0("fase_sessao_",ano,".csv"))
write.csv2(discurso, paste0(pasta, "discurso_",ano,".csv"))
}
# http://www.camara.leg.br/SitCamaraWS/Proposicoes.asmx/ObterVotacaoProposicao?tipo=MSC&numero=950&ano=1989
####################################################
# Carrega o inteiro teor dos discursos a partir
# do sítio de dados abertos da Câmara dos Deputados
#
# Inteiro teor - discursos plenário
# http://www2.camara.leg.br/transparencia/dados-abertos/dados-abertos-legislativo/webservices/sessoesreunioes-2/obterinteiroteordiscursosplenario
####################################################
library(RCurl)
library(stringr)
library(magrittr)
library(XML)
trim <- function (x){
x <- gsub("\n", "", x)
str_trim(x)
}
# marca o momento do início do algorítmo
ptm <- proc.time()
print('Início')
print(ptm)
# define a quantidade de linhas a serem descarregadas
# no arquivo para otimização da memória
gravarLinhas <- 500
# pasta para a gravação dos arquivos
pasta <- "..\\..\\Dados\\"
for(ano in 2017:2017){
discurso <- read.csv(paste0(pasta,"discurso_",ano,".csv"), sep=";", colClasses = "character")
# ajusta campos para leitura da URL tirnado espaços em branco
names(discurso)[1]      <- "seq"
discurso$codigoSessao   <- trim(discurso$codigoSessao)
discurso$numeroQuarto   <- trim(discurso$numeroQuarto)
discurso$numeroInsercao <- trim(discurso$numeroInsercao)
discurso$numeroOrador   <- trim(discurso$numeroOrador)
discurso$sumario        <- trim(discurso$sumario)
inteiroTeor <- NULL
linhas <- nrow(discurso)
i <- 1
while(i <= linhas){
# monta o id com base no ano e no sequencial do discurso
id <- paste0('00000',discurso$seq[i])
id <- substr(id,str_length(id)-4,str_length(id))
id <- paste0(ano,id)
if(discurso$sumario[i] != ""){
# monta a URL com base no ano e período
url <- paste0("http://www.camara.leg.br/SitCamaraWS/SessoesReunioes.asmx/obterInteiroTeorDiscursosPlenario",
"?codSessao=",discurso$codigoSessao[i],
"&numOrador=",discurso$numeroOrador[i],
"&numQuarto=",discurso$numeroQuarto[i],
"&numInsercao=",discurso$numeroInsercao[i])
# tenta ler a URL ...
data <- try(xmlParse(url, isURL=TRUE, asTree = TRUE, useInternalNodes = TRUE), TRUE)
if(typeof(data) == "externalptr"){ # caso tenha conseguido ler o conteúdo da URL ...
# converte formato XML para lista do R
xml_data <- xmlToList(data)
# cria data.frame temporário (df) com os dados lidos e adiciona a inteiroTeor
df <- data.frame(id,
horaInicioDiscurso = trim(xml_data$horaInicioDiscurso),
discurso = xml_data$discursoRTFBase64)
inteiroTeor <- rbind(inteiroTeor, df)
# informa no console
print(paste0(ano,' - ',i,':',linhas))
} else { # caso ocorra um erro ...
if(grepl("huge text node",data)) { # verifica se é um texto longo
# insere NA provisoriamente até a inspeção visual
df <- data.frame(id, horaInicioDiscurso = NA, discurso = NA)
inteiroTeor <- rbind(inteiroTeor, df)
# cria arquivo com lista dos discursos longos para inspeção visual
write.table(x=data.frame(ano, seq=discurso$seq[i], url),
sep=";",
file="TextoLongo.csv",
append=TRUE,
row.names=FALSE,
col.names=FALSE)
}else {# se for outro erro, de conexao, por exemplo, tenta novamente
print(paste0('Erro - ',i,':',linhas))
i <- i - 1
Sys.sleep(0.5)
}
}
} else{ # caso não haja discurso disponível, preenche com NA
df <- data.frame(id, horaInicioDiscurso = NA, discurso = NA)
inteiroTeor <- rbind(inteiroTeor, df)
}
# otimização de memória
if(i == gravarLinhas){ # ao atingir a qtde de linhas a serem gravadas ...
# grava as linhas com inteiro teor no arquivo ...
write.table(x=inteiroTeor, sep=";",
file=paste0(pasta, "discurso_",ano,"_dit.csv"),
append=TRUE,
row.names=FALSE,
col.names=FALSE)
# deduz do data.frame discurso as linhas gravadas
discurso <- discurso[(gravarLinhas+1):linhas,]
inteiroTeor <- NULL
# recalcula o número de linhas de discurso
linhas <- nrow(discurso)
# reinicia a contagem
i <- 0
print("Gravou")
}
i <- i + 1
}
# marca o momento final da execução do algorítmo
print(proc.time() - ptm)
ptm <- proc.time()
# grava o último bloco de linhas no arquivo
write.table(x=inteiroTeor, sep=";",
file=paste0(pasta, "discurso_",ano,"_dit.csv"),
append=TRUE,
row.names=FALSE,
col.names=FALSE)
}
###############################################################
# Verifica integridade entre lista de discursos e inteiro teor
# por meio do batimento entre o número de linhas
###############################################################
# pasta para a leitura dos arquivos
pasta <- "..\\..\\Dados\\"
for(ano in c(2017,2017)){
# lista de discursos
ld <- read.csv2(paste0(pasta, "discurso_",ano,".csv"), sep=";", colClasses = "character")
# inteiro teor
it <- read.csv2(paste0(pasta, "discurso_",ano,"_dit.csv"), header = FALSE, sep=";", colClasses = "character")
print(paste0('Ano: ', ano, '  Lista: ', nrow(ld), ' - Inteiro Teor: ', nrow(it), ' ', nrow(ld)==nrow(it)))
ld <- NULL
it <- NULL
}
setwd("F:/_Pesquisa/PosDoc/_Github/02_2017MaiJun")
